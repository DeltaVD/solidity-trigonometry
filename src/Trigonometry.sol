/**
 * Basic trigonometry functions
 *
 * Solidity library offering the functionality of basic trigonometry functions
 * with both input and output being integer approximated.
 *
 * This is useful since:
 * - At the moment no floating/fixed point math can happen in solidity
 * - Should be (?) cheaper than the actual operations using floating point
 *   if and when they are implemented.
 *
 * The implementation is based off Dave Dribin's trigint C library
 * http://www.dribin.org/dave/trigint/
 * Which in turn is based from a now deleted article which can be found in
 * the internet wayback machine:
 * http://web.archive.org/web/20120301144605/http://www.dattalo.com/technical/software/pic/picsine.html
 *
 * @author Lefteris Karapetsas
 * @license BSD3
 */

pragma solidity ^0.8.7;

library Trigonometry {
  // Table index into the trigonometric table
  uint256 constant INDEX_WIDTH        = 4;
  // Interpolation between successive entries in the tables
  uint256 constant INTERP_WIDTH       = 8;
  uint256 constant INDEX_OFFSET       = 12 - INDEX_WIDTH;
  uint256 constant INTERP_OFFSET      = INDEX_OFFSET - INTERP_WIDTH;
  uint16  constant ANGLES_IN_CYCLE    = 16384;
  uint16  constant QUADRANT_HIGH_MASK = 8192;
  uint16  constant QUADRANT_LOW_MASK  = 4096;
  uint256 constant SINE_TABLE_SIZE    = 16;

  // Pi as an 18 decimal value, which is plenty of accuracy: "For JPL's highest accuracy calculations, which are for
  // interplanetary navigation, we use 3.141592653589793: https://www.jpl.nasa.gov/edu/news/2016/3/16/how-many-decimals-of-pi-do-we-really-need/
  uint256 constant PI          = 3141592653589793238;
  uint256 constant TWO_PI      = 2 * PI;
  uint256 constant PI_OVER_TWO = PI / 2;

  // Constant sine lookup table generated by generate_trigonometry.py from the source repo.
  // We have no other choice but this since constant arrays still are not supported in Solidity
  uint8 constant entry_bytes = 2;
  bytes constant sin_table   = hex"00_00_0c_8c_18_f9_25_28_30_fb_3c_56_47_1c_51_33_5a_82_62_f1_6a_6d_70_e2_76_41_7a_7c_7d_89_7f_61_7f_ff";

  /**
   * @notice Return the sine of a value, specified in radians scaled by 1e18
   * @dev This algorithm for converting sine only uses integer values, and it works by dividing the
   * circle into a 14 bit angles, i.e. there are 16384  angle units, instead of the standard 360
   * degrees or 2pi radians. From there, we get an output in range -32767 to 32767, which is then
   * converted back to the standard range of -1 to 1, again scaled by 1e18
   * @param _angle Angle to convert
   * @return Result scaled by 1e18
   */
  function sin(uint256 _angle) public pure returns (int256) {
    // Convert angle from from arbitrary radian value (range of 0 to 2pi) to the algorithm's range of 0 to 16384
    unchecked {
      _angle = ANGLES_IN_CYCLE * (_angle % TWO_PI) / 2 / PI;

      // Apply a mask on an integer to extract a certain number of bits, where angle is the integer
      // whose bits we want to get, the width is the width of the bits (in bits) we want to extract,
      // and the offset is the offset of the bits (in bits) we want to extract. The result is an
      // integer containing _width bits of _value starting at the offset bit
      uint256 interp = (_angle >> INTERP_OFFSET) & ((1 << INTERP_WIDTH) - 1);
      uint256 index  = (_angle >> INDEX_OFFSET)  & ((1 << INDEX_WIDTH)  - 1);

      // The lookup table only contains data for one quadrant (since sin is symmetric around both
      // axes), so here we figure out which quadrant we're in, then we lookup the values in the
      // table and modify them accordingly
      bool is_odd_quadrant      = (_angle & QUADRANT_LOW_MASK)  == 0;
      bool is_negative_quadrant = (_angle & QUADRANT_HIGH_MASK) != 0;

      if (!is_odd_quadrant) {
        index = SINE_TABLE_SIZE - 1 - index;
      }

      // Index into the lookup table and returns the values at indices `index` and `index + 1`
      bytes memory table = sin_table;
      uint256 offset1 = (index + 1) * entry_bytes;
      uint256 offset2 = (index + 2) * entry_bytes;
      uint16 x1; assembly { x1 := mload(add(table, offset1)) }
      uint16 x2; assembly { x2 := mload(add(table, offset2)) }
      uint256 approximation = ((x2 - x1) * interp) >> INTERP_WIDTH;
      int256 sine = is_odd_quadrant ? int256(uint256(x1)) + int256(approximation) : int256(uint256(x2)) - int256(approximation);

      if (is_negative_quadrant) {
        sine *= -1;
      }

      // Bring result from the range of -32767 through 32767 to -1e18 through 1e18.
      // This can never overflow because sine is bounded by the above values
      return sine * 1e18 / 32767;
    }
  }

  /**
   * @notice Return the cosine of a value, specified in radians scaled by 1e18
   * @dev This is identical to the sin() method, and just computes the value by delegating to the
   * sin() method using the identity cos(x) = sin(x + pi/2)
   * @param _angle Angle to convert
   * @return Result scaled by 1e18
   */
  function cos(uint256 _angle) public pure returns (int256) {
    return sin(_angle + PI_OVER_TWO);
  }
}
